function lisa = lisa_struct_cu_by_eu_xref_ver0(lisa,annot,ontology,percentile_);

%%%%%%%%;
cu_ = lisa.cdrop_a_;
so_ = lisa.so_;
su_ = lisa.su_;
so_to_su_ = lisa.so_to_su_;
su_to_so_ = lisa.su_to_so_;
so_by_su_xref_ = lisa.so_by_su_xref_;
tu_ = lisa.tu_;
su_to_tu_ = lisa.su_to_tu_;
ru_to_tu_ = lisa.ru_to_tu_;
tu_by_ru_xref_ = lisa.tu_by_ru_xref_;
cu_to_cu__ = lisa.cu_to_cu__;
cu_to_cu_mc_ = lisa.cu_to_cu_mc_;
cu_mc_ = lisa.cu_mc_;
%%%%%%%%;
n_ru = annot.n_ru;
ln_ = annot.ln_;
ru_ = annot.ru_;
eo__ = annot.eo__;
eu_max = annot.eu_max;
eo_ = annot.eo_;
ru_to_eo_ = annot.ru_to_eo_;
eu_ = annot.eu_;
eo_to_eu_ = annot.eo_to_eu_;
eu_to_eo_ = annot.eu_to_eo_;
ru_by_eu_xref_ = annot.ru_by_eu_xref_;
%%%%%%%%;
n_pathway = ontology.n_pathway;
pathway_name_ = ontology.pathway_name_;
pathway_size_ = ontology.pathway_size_;
po__ = ontology.po__;
po_ = ontology.po_;
pu_ = ontology.pu_;
po_to_pu_ = ontology.po_to_pu_;
pu_to_po_ = ontology.pu_to_po_;
qu_ = ontology.qu_;
eu_to_qu_ = ontology.eu_to_qu_;
pu_to_qu_ = ontology.pu_to_qu_;
eu_to_qu_xref_ = ontology.eu_to_qu_xref_;
pu_to_qu_xref_ = ontology.pu_to_qu_xref_;

%%%%%%%%%%%%%%%%;
% cu_by_eu_xref__ is a sparse matrix with rows indexing cu_, columns indexing the unique EZids, ;
% and sparse entries indicating which entries of cu_ are associated with which genes. ;
% cu_by_eu_xref_XX__ is a cell array: cu_by_eu_xref_XX__{npcercentile} is a sparse matrix with rows indexing cu_, columns indexing the unique EZids, ;
% and sparse entries indicating which entry of cu_ is associated with the XX-percentile for each gene. ;
% Note that the actual rsid taken from so_{find(cu_by_eu_xref_XX__{npercentile}(:,ng_EZ))} will not necessarily correspond to the gene indexed by eu_(ng_EZ). ;
% This is because the indices of find(cu_by_eu_xref_XX__{npercentile}(:,ng_EZ)) are designed to be percentiles referencing the distribution of indices within cu_ associated with eu_(ng_EZ). ;
% Thus, find(cu_by_eu_xref_XX__{percentile==00}(:,ng_EZ)) and find(cu_by_eu_xref_XX__{percentile==100}(:,ng_EZ)) will correspond to the first and last entries of cu_ associated with eu_(ng_EZ), ;
% but the intermediate find(cu_by_eu_xref_XX__{percentile==50}(:,ng_EZ)) may not. ;
n_total = 0; n_total_XX = 0;
n_percentile = length(percentile_);
cu_by_eu_xref__ = cell(n_percentile,1); 
clear tmp10_ tmp11_ tmp12_ tmp13_ tmp13_XX_;
clear tmp10_XX__;
for nqu=1:length(qu_);
npu = pu_to_qu_(nqu); neu = eu_to_qu_(nqu);
tmp_eo_ = eu_(neu); %<-- this is merely a single EZid, which should already be within eu_. ;
tmp_po_ = pu_(npu); %<-- this is merely a single EZid, which should already be within pu_. ;
assert(tmp_eo_==tmp_po_);
tmp0_ = find(pu_to_qu_xref_(tmp_po_)>0); %<-- not necessary here. ;
tmp0_ = pu_to_qu_xref_(tmp_po_(tmp0_)); %<-- this should be nothing more than npu. ;
tmp0_ = pu_(tmp0_); %<-- now tmp0_ stores only the EZid within pu_. ;
tmp1_ = find(eu_to_qu_xref_(tmp0_)>0); %<-- now tmp1_ indicates which of the the EZid within pu_ are also within eu_. ;
tmp2_ = eu_to_qu_xref_(tmp0_(tmp1_)); %<-- now tmp2_ allows us to reference the EZid within pu_ that are also within eo_uni. ; That is, eu_(tmp2_) will list the actual EZids in this intersection. ;
tmp3_ = eu_(tmp2_); %<-- now tmp3_ stores only the EZid within eu_ and pu_. ;
tmp4_ = find(sum(ru_by_eu_xref_(:,tmp2_),2)); %<-- now tmp4_ indexes the snp ids from ru_ associated with the genes in the pathway. ;
flag_check=0;
if flag_check;
disp(sprintf(' %% checking tmp4_ length %d',length(tmp4_)));
for nl=1:length(tmp4_);
assert(length(intersect(eo__{tmp4_(nl)},tmp3_))>0);
end;%for nl=1:length(tmp4_);
end;%if flag_check;
%{
[~,tmp5_,tmp6_] = intersect(ru_to_tu_,tmp4_,'stable'); %<-- tmp4_(tmp6_) contains the ru_ indices associated with snps in cap_snp_sort_uni_. ;
tmp7b_ = su_to_tu_(tmp5_); %<-- now su_(tmp7b_) should equal ru_(tmp4_(tmp6_));
flag_check=0;
if flag_check;
disp(sprintf(' %% checking tmp6_ length %d',length(tmp6_)));
for nl=1:length(tmp6_);
assert(strcmp(su_(tmp7b_(nl)),ru_(tmp4_(tmp6_(nl)))));
end;%for nl=1:length(tmp6_);
end;%if flag_check;
 %}
tmp7_ = su_to_tu_(find(sum(tu_by_ru_xref_(:,tmp4_),2)));%<-- now su_(tmp7_) should equal ru_(tmp4_(tmp6_)), where [~,~,tmp6_] = intersect(ru_to_tu_,tmp4_,'stable');
flag_check=0;
if flag_check;
[~,~,tmp6_] = intersect(ru_to_tu_,tmp4_,'stable');
assert(sum(strcmp(su_(tmp7_),ru_(tmp4_(tmp6_))))==length(tmp7_));
end;%if flag_check;
%plot (tmp7_-tmp7b_,'.'); %<-- this should be all zeros. ;
tmp8_ = find(sum(so_by_su_xref_(:,tmp7_),2)>0); %<-- now so_(tmp8_) should contain only names from su_(tmp7_);
flag_check=0;
if flag_check;
disp(sprintf(' %% checking tmp8_ length %d',length(tmp8_)));
assert(length(intersect(so_(tmp8_),su_(tmp7_)))==length(tmp7_));
assert(length(union(so_(tmp8_),su_(tmp7_)))==length(tmp7_));
end;%if flag_check;
tmp9_ = cu_(tmp8_); %<-- these are the snp column-indices listed in cdrop_a which correspond to the genes in the pathway. ;
tmp10_(n_total + (1:length(tmp8_))) = tmp8_; %<-- we store only the actual rank-order within cdrop_a for each of the snps associated with the genes in the pathway. ;
tmp11_(n_total + (1:length(tmp8_))) = npu; %<-- indexing pu_. ;
tmp12_(n_total + (1:length(tmp8_))) = tmp_po_; %<-- actual EZid . ;
tmp13_(n_total + (1:length(tmp8_))) = neu; %<-- index such that eu_(neu)==tmp_po_.;
n_total = n_total + length(tmp8_);
if length(tmp8_)>0;
for npercentile=1:n_percentile;
tmp_cXX_ = max(1,min(length(cu_),round(prctile(tmp8_,percentile_(npercentile)))));
tmp10_XX__{npercentile}(n_total_XX + 1) = tmp_cXX_;
end;%for npercentile=1:n_percentile;
tmp13_XX_(n_total_XX + 1) = neu;
n_total_XX = n_total_XX + 1;
end;%if length(tmp8_)>0;
end;%for nqu=1:length(qu_);
%%%%%%%%;
cu_by_eu_xref__ = sparse(tmp10_,tmp13_,1,length(cu_),length(eu_)); %<-- Now cu_by_eu_xref__ can be used to cross-reference entries of cu_ and genes. ;
for npercentile=1:n_percentile;
cu_by_eu_xref_XX__{npercentile} = sparse(tmp10_XX__{npercentile},tmp13_XX_,1,length(cu_),length(eu_));
end;%for npercentile=1:n_percentile;
% i.e., if a list of EZids from eo_ is given by eu_(neu_), then tmp3_ = find(sum(cu_by_eu_xref__(:,neu_),2)) can be used to find the entries of cu_ associated with those EZids. ;
% More specifically, lisa.bim__id_(cu_(tmp3_)) == so_(tmp3_) lists the (string) rsids such that, for tmp4_ = find(strcmp(ru_,so_(tmp3_))), each of the eo__{tmp4_(nl)} lists a set of EZids such that at least one is within the original list from eu_(neu_). ;
flag_test=0;
if flag_test;
neu_ = randperm(length(eu_)); neu_ = neu_(1:20);
disp(sprintf(' %% selecting %d genes from within eu_. ',length(neu_)));
for nl2=1:length(neu_);
tmp3_ = find(sum(cu_by_eu_xref__(:,neu_(nl2)),2));
if (length(tmp3_)>0);
assert(find(sum(cu_by_eu_xref_99__(:,neu_(nl2)),2))==max(tmp3_));
assert(find(sum(cu_by_eu_xref_01__(:,neu_(nl2)),2))==min(tmp3_));
end;%if (length(tmp3_)>0);
if (length(tmp3_)==0);
assert(isempty(find(sum(cu_by_eu_xref_99__(:,neu_(nl2)),2))));
assert(isempty(find(sum(cu_by_eu_xref_01__(:,neu_(nl2)),2))));
end;%if (length(tmp3_)==0);
end;%for nl2=1:length(neu_);
tmp3_ = find(sum(cu_by_eu_xref__(:,neu_),2)); 
disp(sprintf(' %% found %d corresponding entries of cu_. ',length(tmp3_)));
for nl1=1:length(tmp3_);
tmp4_ = find(strcmp(ru_,so_(tmp3_(nl1))));
disp(sprintf(' %% %% entry %d/%d, found %d snps',nl1,length(tmp3_),length(tmp4_)));
for nl2=1:length(tmp4_);
assert(length(intersect(eo__{tmp4_(nl2)},eu_(neu_)))>0);
end;%for nl2=1:length(tmp4_);
end;%for nl1=1:length(tmp3_);
end;%if flag_test;

lisa.n_percentile = n_percentile;
lisa.percentile_ = percentile_;
lisa.cu_by_eu_xref__ = cu_by_eu_xref__;
lisa.cu_by_eu_xref_XX__ = cu_by_eu_xref_XX__;
