function [xn,nb] = conjgrad_0(An,bn,xn);
% This is designed to solve for the normal equations: ;
% AtAn*xn = At*bn, where An comes from the least-squares problem: ;
% An*xn = bn. ;

if nargin<1;
rng(1); 
n_M = 500; n_N = 12800;
An = randn(n_M,n_N); bn = randn(n_M,1); 
tic; xn_bs = An\bn; t_bs = toc;
tic; [xn_cg,nb] = conjgrad_0(An,bn,zeros(n_N,1)); t_cg = toc;
disp(sprintf(' %% least-squares: [%d-x-%d]: bs vs cg timing: %0.6f vs %0.6f; bs vs cg error: %0.16f/%0.16f; ct iteration %d/%d',n_M,n_N,t_bs,t_cg,norm(xn_cg-xn_bs,'fro'),norm(xn_bs,'fro'),nb,length(bn)));
disp('returning');return;
end;%if nargin<1;

verbose=0;
Anxn = An*xn;
At = transpose(An);
AtAnxn = At*Anxn;
Atbn = At*bn;
rn = Atbn - AtAnxn;
rt = transpose(rn);
pn = rn;
pt = transpose(pn);
r2_old = rt * rn;
for nb = 1:length(bn);
Anpn = An*pn;
AtAnpn = At*Anpn;
alpha = r2_old / (pt*AtAnpn);
xn = xn + alpha * pn;
rn = rn - alpha * AtAnpn;
rt = transpose(rn);
r2_new = rt*rn;
if (verbose); disp(sprintf(' %% ni %d/%d r2 %0.16f',nb,length(bn),r2_new)); end;
if (sqrt(r2_new) < 1e-10); break; end;
pn = rn + (r2_new / r2_old) * pn;
pt = transpose(pn);
r2_old = r2_new;
end;%for nb = 1:length(b);
