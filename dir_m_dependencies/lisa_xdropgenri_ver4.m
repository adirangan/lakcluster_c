clear; setup;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%;
% First we load an ontology;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%;
fname = '/data/rangan/dir_bcc/dir_seek_072916/data/human/go_bp_iea.txt';
fcheck(fname);
fid=fopen(fname);
n_line = 0; flag_continue=1;
flag_continue=1;
while (flag_continue); tmp_ = fgetl(fid); if tmp_~=-1; n_line = n_line+1; else flag_continue=0; end; end;
fclose(fid);
disp(sprintf(' %% reading %s: found %d lines',fname,n_line));
n_pathway = floor(n_line/2);
pathway_name_ = cell(n_pathway,1);
pathway_EZid__ = cell(n_pathway,1);
pathway_size_ = zeros(n_pathway,1);
fid=fopen(fname);
for npathway=1:n_pathway;
tmp_ = fgetl(fid);
pathway_name_{npathway} = tmp_;
tmp_ = fgetl(fid);
pathway_EZid__{npathway} = str2num(tmp_);
pathway_size_(npathway) = length(pathway_EZid__{npathway});
end;%for npathway=1:n_pathway;
fclose(fid);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%;
% If we like we can calculate the pairwise intersection (i.e., gene-overlap) between pathways in the ontology. ;
% This takes a while, and is not all that informative; the summary is that ;
% there are several pathways that are large and strongly overlap with one another, ;
% but also many pathways which are small and rather disparate. ;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%;
flag_cap=0;
if flag_cap;
disp(sprintf(' %% calculating pairwise intersection between pathways'));
pathway_cap_ = zeros(n_pathway,n_pathway);
for np1=1:n_pathway; 
pathway_cap_(np1,np1) = 1.0;
if (mod(np1,100)==0); disp(sprintf(' %% np1 %d/%d',np1,n_pathway)); end;
for np2=np1+1:n_pathway;
tmp = length(intersect(pathway_EZid__{np1},pathway_EZid__{np2}))/max(1,min(pathway_size_(np1),pathway_size_(np2)));
pathway_cap_(np1,np2) = tmp; pathway_cap_(np2,np1) = tmp;
end;%for np2=1:n_pathway;
end;%for np1=1:n_pathway; 
end;%if flag_cap;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%;
% Now load annot file created with: ;
% lisa_annot_to_EZ_ver0('/data/rangan/dir_bcc/dir_PGC_20190328/dir_misc/bip_all_bim_uniq_38_annotat_35_10.genes.annot');
% This file contains: ; 
% rs_sort_ a cell array of snp rsids. ;
% n_rs_sort an integer: n_rs_sort = length(rs_sort_). ;
% EZ__ a cell-array associating snps with genes. ;
% EZ__ a cell-array: EZ__{nsnp} gives the list of (string) EZids associated with the snp with (string) rsid listed in rs_sort_{nsnp}. ;
% ln_ an integer arry: ln_(nsnp) is an integer storing the length of EZ__{nsnp}. ;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%;
fname_mat = '/data/rangan/dir_bcc/dir_PGC_20190328/dir_misc/bip_all_bim_uniq_38_annotat_35_10.genes.annot.mat'; fcheck(fname_mat); load(fname_mat);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%;
% Now we load the results from a few biclustering runs. ;
% The runs we chose are from: ;
dir_trunk = sprintf('/data/rangan/dir_bcc/dir_PGC_20190328');
dir_code = sprintf('/data/rangan/dir_bcc/dir_lakcluster_c_dev');
flag_dex_vs_lak = 'dex'; %<-- differentially expressed clustering. ;
cl_num = 4; cl_num_arm2 = []; %<-- train on platform 4 (replication arm not used). ;
flag_reverse = 0; %<-- forward bicluster (i.e., case-specific). ;
B_MLT = 34; n_mds = 20; mc_string = ''; %<-- accurate to 2^(-34), 20 total mds components (but only 2 used). ; No special mc_string. ;
n_maf = 5; n_cov = 2; %<-- minor-allele-frequency cutoff 25-50, 2 covariates (mds-components) used, repeated twice. ;
n_scramble = 0; n_shuffle = 0; %<-- no previous bicluster extracted/scrambled first, no random shuffling. ;
%%%%%%%%;
gamma_ = [0.000,0.001,0.002,0.004,0.008]; n_gamma = length(gamma_); %<-- gamma is the fraction eliminated per iteration. 000 implies a single patient eliminated per iteration. ;
l_ = cell(n_gamma,1); %<-- a cell array of structures to hold the outputs for each biclustering run. ;
ngammabim = 1; %<-- the gamma index which stores the bim information. ;
for ngamma=1:n_gamma;
gamma = gamma_(ngamma); disp(sprintf(' %% loading ngamma %d/%d; gamma %0.3f',ngamma,n_gamma,gamma));
l_{ngamma} = lisa_struct_make_ver0(mc_string,cl_num,cl_num_arm2,flag_dex_vs_lak,gamma,B_MLT,n_mds,flag_reverse,n_maf,n_cov,n_scramble,n_shuffle) ;
l_{ngamma} = lisa_struct_prefix_ver0(l_{ngamma},dir_code,dir_trunk); 
l_{ngamma}.nshuffle = 0;  l_{ngamma} = lisa_struct_names_ver0(l_{ngamma}); 
l_{ngamma} = lisa_struct_xdrop_ver0(l_{ngamma}); l_{ngamma} = lisa_struct_mdsfam_ver0(l_{ngamma}); 
if (ngamma==1); l_{ngamma} = lisa_struct_bim_ver0(l_{ngamma}); end; %<-- we only load this for one of the runs, since it is large and the same for all of these runs. ;
l_{ngamma} = lisa_struct_mx_ver0(l_{ngamma}); l_{ngamma} = lisa_struct_studyindex_ver0(l_{ngamma}); l_{ngamma} = lisa_struct_trace_ver0(l_{ngamma});
end;%for ngamma=1:n_gamma;
%%%%%%%%;
% Now extracting unique snp-rsids. ;
% Note that, while most snps in cdrop_a are listed three times, ;
% a few are listed only 2 times. ;
% This is because we exclude allelic-combinations with a frequency ;
% lower than maf_cutoff^2 (in this case 0.25^2 = 0.0625). ;
%%%%%%%%;
flag_test=1;
if flag_test;
ngamma = 1;
tmp_rs_drop_a_ = l_{ngammabim}.bim__id_(l_{ngamma}.cdrop_a_);
[~,tmp0_,tmp1_] = unique(tmp_rs_drop_a_);
tmp2_ = sort(tmp1_);
tmp3_ = diff(tmp2_);
tmp4_ = diff(find(diff(tmp3_)>0)); disp(sprintf(' %% %d snps listed 3 times, %d snps listed only twice, %d snps listed only once.',length(find(tmp4_==3)),length(find(tmp4_==2)),length(find(tmp4_==1))));
if flag_test>1;
tmp_example = 1+min(find(tmp4_==2));
disp(sprintf(' %% tmp_rs_drop_a_(find(tmp1_==tmp_example)):')); disp(tmp_rs_drop_a_(find(tmp1_==tmp_example)));
disp(sprintf(' %% l_{ngammabim}.bim_alt_(l_{ngamma}.cdrop_a_(find(tmp1_==tmp_example))): allele type '));
disp(l_{ngammabim}.bim_alt_(l_{ngamma}.cdrop_a_(find(tmp1_==tmp_example))));
disp(sprintf(' %% l_{ngammabim}.bim_frq_(l_{ngamma}.cdrop_a_(find(tmp1_==tmp_example))): allele frequency '));
disp(l_{ngammabim}.bim_frq_(l_{ngamma}.cdrop_a_(find(tmp1_==tmp_example))));
disp(sprintf(' %% l_{ngammabim}.bim_maf_(l_{ngamma}.cdrop_a_(find(tmp1_==tmp_example))): snp frequency '));
disp(l_{ngammabim}.bim_maf_(l_{ngamma}.cdrop_a_(find(tmp1_==tmp_example))));
disp(sprintf(' %% l_{ngammabim}.bim_maf_(l_{ngamma}.cdrop_a_(find(tmp1_==tmp_example)))^2: min(snp_frequency^2,(1-snp_frequency)^2) '));
disp(min(l_{ngammabim}.bim_maf_(l_{ngamma}.cdrop_a_(find(tmp1_==tmp_example))).^2,(1-l_{ngammabim}.bim_maf_(l_{ngamma}.cdrop_a_(find(tmp1_==tmp_example)))).^2));
end;%if flag_test>1;
end;%flag_test=1;
%%%%%%%%;
% Now we pick a specific value of gamma to look at: ;
%%%%%%%%;
ngamma = 1; %<-- chosen gamma index to look at. ;
cu_ = l_{ngamma}.cdrop_a_ ; %<-- temporary variable storing the column indices in the order ejected. ;
c_rem_ = l_{ngamma}.c_rem_ ; %<-- temporary variable storing the number of columns remaining at each iteration. ;
niter_ = l_{ngamma}.niter_ ; %<-- temporary variable storing the iteration-number for each iteration, starting at 0 (i.e., 0,1,2,...). ;
%%%%%%%%;
% ru_ contains the (unique) names in rs_sort_. ;
% so_ contains the names of the snps listed in cu_. ;
% tu_ is the minimal set of snp-names which is in the intersection of both ru_ and so_. ;
% so_by_su_xref_ is a sparse matrix that can be used to cross-reference the entries of cu_ with the unique snp-names stored in su_. ;
% i.e., : given a list of unique indices su_(nsu_), ;
% we have nso_ = find(sum(so_by_su_xref_(:,nsu_),2)>0) returns the corresponding indices from within cu_. ;
% That is to say, unique(so_(nso_)) should match unique(su_(nsu_)). ;
%%%%%%%%;
ru_ = rs_sort_; %<-- already unique. ;
n_ru = length(ru_);
so_ = l_{ngammabim}.bim__id_(cu_); %<-- snp__id for each snp in bim_. ;
[su_,so_to_su_,su_to_so_] = unique(so_);
so_by_su_xref_ = sparse(1:length(so_),su_to_so_,1,length(so_),length(su_));
flag_test=0;
if flag_test;
nsu_ = randperm(length(su_)); nsu_ = nsu_(1:floor(end/3));
nso_ = find(sum(so_by_su_xref_(:,nsu_),2)>0);
assert(length(intersect(unique(so_(nso_)),unique(su_(nsu_))))==length(nsu_));
end;%if flag_test;
[tu_,su_to_tu_,ru_to_tu_] = intersect(su_,ru_,'stable');
tu_by_ru_xref_ = sparse(1:length(ru_to_tu_),ru_to_tu_,1,length(ru_to_tu_),length(ru_)); %<-- this can be used to cross-reference indices referencing snps in ru_ with those referencing entries in ru_to_tu_. ;
flag_test=1;
if flag_test;
n_found = 0;
for nru=1:length(ru_);
ntu = find(tu_by_ru_xref_(:,nru));
if (~isempty(ntu));
assert(ru_to_tu_(ntu)==nru);
n_found = n_found+1;
end;%if (~isempty(ntu));
end;%for nru=1:length(ru_);
disp(sprintf(' %% testing tu_by_ru_xref_; n_found %d/%d',n_found,length(tu_)));
end;%if flag_test;
%%%%%%%%;
% eo__ is a cell array: eo__{nru} contains the EZids associated with snp__id ru_(nru) ; 
% eo_ is an array of (nonunique) EZids created from eo__. ;
%%%%%%%%;
eo__ = cell(n_ru,1);
for nru=1:n_ru;
tmp_ = zeros(ln_(nru),1);
for nln=1:ln_(nru);
tmp_(nln) = str2num(EZ__{nru}{nln});
end;%for nln=1:ln_(nru);
eo__{nru} = tmp_;
end;%for nru=1:n_ru;
%%%%%%%%;
eu_max = 0; for nru=1:n_ru; eu_max = max(eu_max,max(eo__{nru})); end;
n_ln = sum(ln_);
ru_to_eo_ = zeros(n_ln,1);
eo_ = zeros(n_ln,1);
n_tmp = 0;
for nru=1:n_ru;
nln = ln_(nru);
tmp_ij_ = n_tmp + (1:nln);
ru_to_eo_(tmp_ij_) = nru;
eo_(tmp_ij_) = eo__{nru};
n_tmp = n_tmp + nln;
end;%for nru=1:n_ru;
%%%%%%%%;
%%%%%%%%;
% eu_ is an array of unique EZids drawn from eo_. ;
% ru_by_eu_xref_ is a sparse matrix with rows indexing ru_, columns indexing eu_, ;
% and sparse entries indicating which snps are associated with which genes. ;
%%%%%%%%;
[eu_,eo_to_eu_,eu_to_eo_] = unique(eo_);
ru_by_eu_xref_ = sparse(ru_to_eo_,eu_to_eo_,1); %<-- Now ru_by_eu_xref_ can be used to cross-reference snps and genes. ;
% i.e., if a list of EZids from eo_ is given by eu_(neu_), then nru_ = find(sum(ru_by_eu_xref_(:,neu_),2)) can be used to find the snps associated with those EZids. ;
% More specifically, ru_{nru_} lists the (string) rsids such that each of the eo__{nru_(nl)} lists a set of EZids such that at least one is within the original list from eu_(neu_). ;
flag_test=0;
if flag_test;
neu_ = randperm(length(eu_)); neu_ = neu_(1:floor(end/30));
nru_ = find(sum(ru_by_eu_xref_(:,neu_),2)); 
for nl=1:length(nru_);
nru = nru_(nl);
assert(length(intersect(eo__{nru},eu_(neu_)))>0);
end;%for nl=1:length(nru_);
end;%if flag_test;
%%%%%%%%;
% now check;
%%%%%%%%;
flag_test=0;
if flag_test;
h_s2_ = hist(sum(ru_by_eu_xref_,2),1:44); 
h_s1_ = hist(sum(ru_by_eu_xref_,1),1:1024);
subplot(1,2,1); stairs(h_s2_); title('number of eu per ru'); %<-- Seems like, on average, eash snp is referenced by 2-3 genes. ;
subplot(1,2,2); stairs(h_s1_); title('number of ru per eu');  %<-- Seems like, on average, each gene is referenced by 35-40 snps. ;
end;%if flag_test;
%%%%%%%%;
% Now determine which snps are associated with each pathway. ;
% po__ is a cell array: po__{npathway} contains the EZids associated with pathway_name_{npathway}. ;
% po_ is an array of (nonunique) EZids created from po__. ;
%%%%%%%%;
po__ = pathway_EZid__;
po_ = zeros(sum(pathway_size_),1);
tmp=0;
for npathway=1:n_pathway;
po_(tmp + (1:pathway_size_(npathway))) = po__{npathway};
tmp = tmp+pathway_size_(npathway);
end;%for npathway=1:n_pathway;
pathway_EZmax = max(po_);
cup_EZmax = max(eu_max,pathway_EZmax);
[pu_,po_to_pu_,pu_to_po_] = unique(po_);
[qu_,eu_to_qu_,pu_to_qu_] = intersect(eu_,pu_,'stable');
eu_to_qu_xref_ = sparse(qu_,1,eu_to_qu_,cup_EZmax,1); %<-- this can be used to cross-reference EZids. i.e., eu_(eu_to_qu_xref_(qu_(nEZ))) == qu_(nEZ);
%plot(qu_ - eu_(eu_to_qu_xref_(qu_)),'.'); %<-- should be all zeros. ;
pu_to_qu_xref_ = sparse(qu_,1,pu_to_qu_,cup_EZmax,1); %<-- this can be used to cross-refence EZids. i.e,. pu_(pu_to_qu_xref_(qu_(nEZ))) == qu_(nEZ);
%plot(qu_ - pu_(pu_to_qu_xref_(qu_)),'.'); %<-- should be all zeros. ;
%%%%%%%%;

%%%%%%%%%%%%%%%%;
% link pathways with snps in cu_ by taking the union overall snp-sets for each gene.; 
%%%%%%%%%%%%%%%%;
cu_to_cu__ = cell(n_pathway,1); %<-- this will hold the snp-indices (as entries of cu_) associated with the snps in each pathway. ; i.e., l_{ngammabim}.bim__id_(cu_(cu_to_cu__{npathway})) will hold the (string) rsids associated with pathway_name_{npathway}. ;
for npathway=1:n_pathway;
tmp_pathway_name = pathway_name_{npathway};
tmp_po_ = po__{npathway};
tmp_pathway_size = pathway_size_(npathway);
disp(sprintf(' %% npathway %d/%d name %s size %d',npathway,n_pathway,tmp_pathway_name,tmp_pathway_size));
tmp0_ = find(pu_to_qu_xref_(tmp_po_)>0);
tmp0_ = pu_(pu_to_qu_xref_(tmp_po_(tmp0_))); %<-- now tmp0_ stores only the EZid within pu_. ;
tmp1_ = find(eu_to_qu_xref_(tmp0_)>0); %<-- now tmp1_ indicates which of the the EZid within pu_ are also within eu_. ;
tmp2_ = eu_to_qu_xref_(tmp0_(tmp1_)); %<-- now tmp2_ allows us to reference the EZid within pu_ that are also within eo_uni. ; That is, eu_(tmp2_) will list the actual EZids in this intersection. ;
tmp3_ = eu_(tmp2_); %<-- now tmp3_ stores only the EZid within eu_ and pu_. ;
tmp4_ = find(sum(ru_by_eu_xref_(:,tmp2_),2)); %<-- now tmp4_ indexes the snp ids from ru_ associated with the genes in the pathway. ;
flag_check=0;
if flag_check;
disp(sprintf(' %% checking tmp4_ length %d',length(tmp4_)));
for nl=1:length(tmp4_);
assert(length(intersect(eo__{tmp4_(nl)},tmp3_))>0);
end;%for nl=1:length(tmp4_);
end;%if flag_check;
%{
[~,tmp5_,tmp6_] = intersect(ru_to_tu_,tmp4_,'stable'); %<-- tmp4_(tmp6_) contains the ru_ indices associated with snps in cap_snp_sort_uni_. ;
tmp7b_ = su_to_tu_(tmp5_); %<-- now su_(tmp7b_) should equal ru_(tmp4_(tmp6_));
flag_check=0;
if flag_check;
disp(sprintf(' %% checking tmp6_ length %d',length(tmp6_)));
for nl=1:length(tmp6_);
assert(strcmp(su_(tmp7b_(nl)),ru_(tmp4_(tmp6_(nl)))));
end;%for nl=1:length(tmp6_);
end;%if flag_check;
 %}
tmp7_ = su_to_tu_(find(sum(tu_by_ru_xref_(:,tmp4_),2)));%<-- now su_(tmp7_) should equal ru_(tmp4_(tmp6_)), where [~,~,tmp6_] = intersect(ru_to_tu_,tmp4_,'stable');
flag_check=0;
if flag_check;
[~,~,tmp6_] = intersect(ru_to_tu_,tmp4_,'stable');
assert(sum(strcmp(su_(tmp7_),ru_(tmp4_(tmp6_))))==length(tmp7_));
end;%if flag_check;
%plot (tmp7_-tmp7b_,'.'); %<-- this should be all zeros. ;
flag_check=0;
if flag_check;
disp(sprintf(' %% found tmp7_ of length %d',length(tmp7_)));
end;%if flag_check;
tmp8_ = find(sum(so_by_su_xref_(:,tmp7_),2)>0); %<-- now so_(tmp8_) should contain only names from su_(tmp7_);
flag_check=0;
if flag_check;
disp(sprintf(' %% checking tmp8_ length %d',length(tmp8_)));
assert(length(intersect(so_(tmp8_),su_(tmp7_)))==length(tmp7_));
assert(length(union(so_(tmp8_),su_(tmp7_)))==length(tmp7_));
end;%if flag_check;
tmp9_ = cu_(tmp8_); %<-- these are the snp column-indices listed in cdrop_a which correspond to the pathway. ;
cu_to_cu__{npathway} = tmp8_; %<-- we store only the actual rank-order within cdrop_a for each of the snps in the pathway. ;
end;%for npathway=1:n_pathway;
%%%%%%%%;
% a-posteriori check. ;
%%%%%%%%;
flag_check=0;
if flag_check;
npathway = 1+floor(n_pathway*rand());
disp(sprintf(' %% npathway %d name %s size %d',npathway,pathway_name_{npathway},pathway_size_(npathway)));
tmp_rs_ = unique(l_{ngammabim}.bim__id_(cu_(cu_to_cu__{npathway})));
disp(sprintf(' %% snps %d (%d unique): ',length(cu_to_cu__{npathway}),length(tmp_rs_)));
for nl=1:length(tmp_rs_);
tmp_ij = find(strcmp(ru_,tmp_rs_{nl}));
%disp(sprintf(' %% nl %d/%d snp %s, EZid intersection %d',nl,length(tmp_rs_),tmp_rs_{nl},length(intersect(eo__{tmp_ij},po__{npathway}))));
assert(length(intersect(eo__{tmp_ij},po__{npathway}))>0);
end;%for nl=1:length(tmp_rs_);
end;%if flag_check;
%%%%%%%%;
% Create mask (of indices along cdrop_a) ;
%%%%%%%%;
cu_to_cu_mc_ = zeros(size(cu_));
cu_mc_ = zeros(l_{ngammabim}.n_snp,1);
for npathway=1:n_pathway;
pathway_snp_size_(npathway) = length(cu_to_cu__{npathway});
cu_to_cu_mc_(cu_to_cu__{npathway}) = cu_to_cu_mc_(cu_to_cu__{npathway}) + 1;
cu_mc_(cu_(cu_to_cu__{npathway})) = 1;
end;%for npathway=1:n_pathway;

%%%%%%%%;
% cu_by_eu_xref__ is a sparse matrix with rows indexing cu_, columns indexing the unique EZids, ;
% and sparse entries indicating which entries of cu_ are associated with which genes. ;
% cu_by_eu_xref_XX__ is a sparse matrix with rows indexing cu_, columns indexing the unique EZids, ;
% and sparse entries indicating which entry of cu_ is associated with the XX-percentile for each gene. ;
% Note that the actual rsid taken from so_{find(cu_by_eu_xref_XX__(:,ng_EZ))} will not necessarily correspond to the gene indexed by eu_(ng_EZ). ;
% This is because the indices of find(cu_by_eu_xref_XX__(:,ng_EZ)) are designed to be percentiles referencing the distribution of indices within cu_ associated with eu_(ng_EZ). ;
% Thus, find(cu_by_eu_xref_01__(:,ng_EZ)) and find(cu_by_eu_xref_99__(:,ng_EZ)) will correspond to the first and last entries of cu_ associated with eu_(ng_EZ), ;
% but the intermediate find(cu_by_eu_xref_25__(:,ng_EZ)) through find(cu_by_eu_xref_75__(:,ng_EZ)) may not. ;
%%%%%%%%;
n_total = 0; n_total_XX = 0; clear tmp10_ tmp11_ tmp12_ tmp13_ tmp10_01_ tmp10_25_ tmp10_50_ tmp10_75_ tmp10_99_ tmp13_XX_;
for nqu=1:length(qu_);
npu = pu_to_qu_(nqu); neu = eu_to_qu_(nqu);
tmp_eo_ = eu_(neu); %<-- this is merely a single EZid, which should already be within eu_. ;
tmp_po_ = pu_(npu); %<-- this is merely a single EZid, which should already be within pu_. ;
assert(tmp_eo_==tmp_po_);
tmp0_ = find(pu_to_qu_xref_(tmp_po_)>0); %<-- not necessary here. ;
tmp0_ = pu_to_qu_xref_(tmp_po_(tmp0_)); %<-- this should be nothing more than npu. ;
tmp0_ = pu_(tmp0_); %<-- now tmp0_ stores only the EZid within pu_. ;
tmp1_ = find(eu_to_qu_xref_(tmp0_)>0); %<-- now tmp1_ indicates which of the the EZid within pu_ are also within eu_. ;
tmp2_ = eu_to_qu_xref_(tmp0_(tmp1_)); %<-- now tmp2_ allows us to reference the EZid within pu_ that are also within eo_uni. ; That is, eu_(tmp2_) will list the actual EZids in this intersection. ;
tmp3_ = eu_(tmp2_); %<-- now tmp3_ stores only the EZid within eu_ and pu_. ;
tmp4_ = find(sum(ru_by_eu_xref_(:,tmp2_),2)); %<-- now tmp4_ indexes the snp ids from ru_ associated with the genes in the pathway. ;
flag_check=0;
if flag_check;
disp(sprintf(' %% checking tmp4_ length %d',length(tmp4_)));
for nl=1:length(tmp4_);
assert(length(intersect(eo__{tmp4_(nl)},tmp3_))>0);
end;%for nl=1:length(tmp4_);
end;%if flag_check;
%{
[~,tmp5_,tmp6_] = intersect(ru_to_tu_,tmp4_,'stable'); %<-- tmp4_(tmp6_) contains the ru_ indices associated with snps in cap_snp_sort_uni_. ;
tmp7b_ = su_to_tu_(tmp5_); %<-- now su_(tmp7b_) should equal ru_(tmp4_(tmp6_));
flag_check=0;
if flag_check;
disp(sprintf(' %% checking tmp6_ length %d',length(tmp6_)));
for nl=1:length(tmp6_);
assert(strcmp(su_(tmp7b_(nl)),ru_(tmp4_(tmp6_(nl)))));
end;%for nl=1:length(tmp6_);
end;%if flag_check;
 %}
tmp7_ = su_to_tu_(find(sum(tu_by_ru_xref_(:,tmp4_),2)));%<-- now su_(tmp7_) should equal ru_(tmp4_(tmp6_)), where [~,~,tmp6_] = intersect(ru_to_tu_,tmp4_,'stable');
flag_check=0;
if flag_check;
[~,~,tmp6_] = intersect(ru_to_tu_,tmp4_,'stable');
assert(sum(strcmp(su_(tmp7_),ru_(tmp4_(tmp6_))))==length(tmp7_));
end;%if flag_check;
%plot (tmp7_-tmp7b_,'.'); %<-- this should be all zeros. ;
tmp8_ = find(sum(so_by_su_xref_(:,tmp7_),2)>0); %<-- now so_(tmp8_) should contain only names from su_(tmp7_);
flag_check=0;
if flag_check;
disp(sprintf(' %% checking tmp8_ length %d',length(tmp8_)));
assert(length(intersect(so_(tmp8_),su_(tmp7_)))==length(tmp7_));
assert(length(union(so_(tmp8_),su_(tmp7_)))==length(tmp7_));
end;%if flag_check;
tmp9_ = cu_(tmp8_); %<-- these are the snp column-indices listed in cdrop_a which correspond to the genes in the pathway. ;
tmp10_(n_total + (1:length(tmp8_))) = tmp8_; %<-- we store only the actual rank-order within cdrop_a for each of the snps associated with the genes in the pathway. ;
tmp11_(n_total + (1:length(tmp8_))) = npu; %<-- indexing pu_. ;
tmp12_(n_total + (1:length(tmp8_))) = tmp_po_; %<-- actual EZid . ;
tmp13_(n_total + (1:length(tmp8_))) = neu; %<-- index such that eu_(neu)==tmp_po_.;
n_total = n_total + length(tmp8_);
if length(tmp8_)>0;
tmp_c01_ = max(1,min(length(cu_),round(prctile(tmp8_,  0))));
tmp_c25_ = max(1,min(length(cu_),round(prctile(tmp8_, 25))));
tmp_c50_ = max(1,min(length(cu_),round(prctile(tmp8_, 50))));
tmp_c75_ = max(1,min(length(cu_),round(prctile(tmp8_, 75))));
tmp_c99_ = max(1,min(length(cu_),round(prctile(tmp8_,100))));
tmp10_01_(n_total_XX + 1) = tmp_c01_;
tmp10_25_(n_total_XX + 1) = tmp_c25_;
tmp10_50_(n_total_XX + 1) = tmp_c50_;
tmp10_75_(n_total_XX + 1) = tmp_c75_;
tmp10_99_(n_total_XX + 1) = tmp_c99_;
tmp13_XX_(n_total_XX + 1) = neu;
n_total_XX = n_total_XX + 1;
end;%if length(tmp8_)>0;
end;%for nqu=1:length(qu_);
%%%%%%%%;
cu_by_eu_xref__ = sparse(tmp10_,tmp13_,1,length(cu_),length(eu_)); %<-- Now cu_by_eu_xref__ can be used to cross-reference entries of cu_ and genes. ;
cu_by_eu_xref_01__ = sparse(tmp10_01_,tmp13_XX_,1,length(cu_),length(eu_));
cu_by_eu_xref_25__ = sparse(tmp10_25_,tmp13_XX_,1,length(cu_),length(eu_));
cu_by_eu_xref_50__ = sparse(tmp10_50_,tmp13_XX_,1,length(cu_),length(eu_));
cu_by_eu_xref_75__ = sparse(tmp10_75_,tmp13_XX_,1,length(cu_),length(eu_));
cu_by_eu_xref_99__ = sparse(tmp10_99_,tmp13_XX_,1,length(cu_),length(eu_));
% i.e., if a list of EZids from eo_ is given by eu_(neu_), then tmp3_ = find(sum(cu_by_eu_xref__(:,neu_),2)) can be used to find the entries of cu_ associated with those EZids. ;
% More specifically, l_{ngammabim}.bim__id_(cu_(tmp3_)) == so_(tmp3_) lists the (string) rsids such that, for tmp4_ = find(strcmp(ru_,so_(tmp3_))), each of the eo__{tmp4_(nl)} lists a set of EZids such that at least one is within the original list from eu_(neu_). ;
flag_test=0;
if flag_test;
neu_ = randperm(length(eu_)); neu_ = neu_(1:20);
disp(sprintf(' %% selecting %d genes from within eu_. ',length(neu_)));
for nl2=1:length(neu_);
tmp3_ = find(sum(cu_by_eu_xref__(:,neu_(nl2)),2));
if (length(tmp3_)>0);
assert(find(sum(cu_by_eu_xref_99__(:,neu_(nl2)),2))==max(tmp3_));
assert(find(sum(cu_by_eu_xref_01__(:,neu_(nl2)),2))==min(tmp3_));
end;%if (length(tmp3_)>0);
if (length(tmp3_)==0);
assert(isempty(find(sum(cu_by_eu_xref_99__(:,neu_(nl2)),2))));
assert(isempty(find(sum(cu_by_eu_xref_01__(:,neu_(nl2)),2))));
end;%if (length(tmp3_)==0);
end;%for nl2=1:length(neu_);
tmp3_ = find(sum(cu_by_eu_xref__(:,neu_),2)); 
disp(sprintf(' %% found %d corresponding entries of cu_. ',length(tmp3_)));
for nl1=1:length(tmp3_);
tmp4_ = find(strcmp(ru_,so_(tmp3_(nl1))));
disp(sprintf(' %% %% entry %d/%d, found %d snps',nl1,length(tmp3_),length(tmp4_)));
for nl2=1:length(tmp4_);
assert(length(intersect(eo__{tmp4_(nl2)},eu_(neu_)))>0);
end;%for nl2=1:length(tmp4_);
end;%for nl1=1:length(tmp3_);
end;%if flag_test;

%%%%%%%%%%%%%%%%;
% link pathways with snps in cu_ by taking only one of the snps from each snp-set for each gene.; 
% The representative snp chosen for each gene will change depending on which percentile (amongst possible representatives) we choose. ;
% Note that, if multiple genes have the same representative, that snp will be counted multiple times. ;
% The total number of representative-snps should equal the total number of genes. ;
%%%%%%%%%%%%%%%%;
% po_XX_cu_get__ = cell(n_pathway,1); %<-- this will hold the snp-indices (as entries of cu_) associated with EZids in each pathway. ; 
% More specifically: l_{ngammabim}.bim__id_(cu_(find(po_XX_cu_get__{npathway}))) will hold the (string) rsids associated with first XX-percentile occurrences of the genes in pathway pathway_name_{npathway}. ;
% Note that we expect l_{ngammabim}.bim__id_(cu_(find(po_01_cu_get__{npathway}))) to hold the first rsid associated with pathway_name_{npathway}. ;
% Similarly, we expect l_{ngammabim}.bim__id_(cu_(find(po_99_cu_get__{npathway}))) to hold the last rsid associated with pathway_name_{npathway}. ;
% However, an intermediate percentile such as l_{ngammabim}.bim__id_(cu_(find(po_25_cu_get__{npathway}))) may not actually correspond to an rsid associated with pathway_name_{npathway}, ;
% simply because this 25th percentile location (along cu_) may actually lie in between two indices which are both in the pathway. ;
po_01_cu_get__ = cell(n_pathway,1); %<-- actually the 00th percentile (i.e., first occurrence). ;
po_25_cu_get__ = cell(n_pathway,1);
po_50_cu_get__ = cell(n_pathway,1);
po_75_cu_get__ = cell(n_pathway,1);
po_99_cu_get__ = cell(n_pathway,1); %<-- actually the 100th percentile (i.e., last occurrence). ;
for npathway=1:n_pathway;
tmp_pathway_name = pathway_name_{npathway};
tmp_po_ = po__{npathway};
tmp_pathway_size = pathway_size_(npathway);
disp(sprintf(' %% npathway %d/%d name %s size %d',npathway,n_pathway,tmp_pathway_name,tmp_pathway_size));
tmp0_ = find(pu_to_qu_xref_(tmp_po_)>0);
tmp0_ = pu_(pu_to_qu_xref_(tmp_po_(tmp0_))); %<-- now tmp0_ stores only the EZid within pu_. ;
tmp1_ = find(eu_to_qu_xref_(tmp0_)>0); %<-- now tmp1_ indicates which of the the EZid within pu_ are also within eu_. ;
tmp2_ = eu_to_qu_xref_(tmp0_(tmp1_)); %<-- now tmp2_ allows us to reference the EZid within pu_ that are also within eo_uni. ; That is, eu_(tmp2_) will list the actual EZids in this intersection. ;
tmp3_ = eu_(tmp2_); %<-- now tmp3_ stores only the EZid within eu_ and pu_. ;
tmp4_c01_ = (sum(cu_by_eu_xref_01__(:,tmp2_),2));%tmp4_c01_ = find(sum(cu_by_eu_xref_01__(:,tmp2_),2)); %<-- now tmp4_ indexes the first entry from cu_ associated with each of the genes in tmp3_(nl2). ;
tmp4_c25_ = (sum(cu_by_eu_xref_25__(:,tmp2_),2));%tmp4_c25_ = find(sum(cu_by_eu_xref_25__(:,tmp2_),2));
tmp4_c50_ = (sum(cu_by_eu_xref_50__(:,tmp2_),2));%tmp4_c50_ = find(sum(cu_by_eu_xref_50__(:,tmp2_),2));
tmp4_c75_ = (sum(cu_by_eu_xref_75__(:,tmp2_),2));%tmp4_c75_ = find(sum(cu_by_eu_xref_75__(:,tmp2_),2));
tmp4_c99_ = (sum(cu_by_eu_xref_99__(:,tmp2_),2));%tmp4_c99_ = find(sum(cu_by_eu_xref_99__(:,tmp2_),2)); %<-- now tmp4_ indexes the last entry from cu_ associated with each of the genes in tmp3_(nl2). ;
po_01_cu_get__{npathway} = tmp4_c01_;
po_25_cu_get__{npathway} = tmp4_c25_;
po_50_cu_get__{npathway} = tmp4_c50_;
po_75_cu_get__{npathway} = tmp4_c75_;
po_99_cu_get__{npathway} = tmp4_c99_;
end;%for npathway=1:n_pathway;
%%%%%%%%;
% a-posteriori check. ;
%%%%%%%%;
flag_check=0;
if flag_check;
npathway = 1+floor(n_pathway*rand());
disp(sprintf(' %% npathway %d name %s size %d',npathway,pathway_name_{npathway},pathway_size_(npathway)));
tmp_rs_01_ = unique(l_{ngammabim}.bim__id_(cu_(find(po_01_cu_get__{npathway}))));
tmp_rs_25_ = unique(l_{ngammabim}.bim__id_(cu_(find(po_25_cu_get__{npathway}))));
tmp_rs_50_ = unique(l_{ngammabim}.bim__id_(cu_(find(po_50_cu_get__{npathway}))));
tmp_rs_75_ = unique(l_{ngammabim}.bim__id_(cu_(find(po_75_cu_get__{npathway}))));
tmp_rs_99_ = unique(l_{ngammabim}.bim__id_(cu_(find(po_99_cu_get__{npathway}))));
disp(sprintf(' %% snps %d (%d unique): ',sum(po_01_cu_get__{npathway})),length(tmp_rs_01_));
for nl=1:length(tmp_rs_01_);
if (mod(nl,100)==0); disp(sprintf(' %% checking tmp_rs_01_(%d)',nl)); end;
tmp_ij_01_ = find(strcmp(ru_,tmp_rs_01_{nl})); assert(length(intersect(eo__{tmp_ij_01_},po__{npathway}))>0);
end;%for nl=1:length(tmp_rs_01_);
for nl=1:length(tmp_rs_99_);
if (mod(nl,100)==0); disp(sprintf(' %% checking tmp_rs_99_(%d)',nl)); end;
tmp_ij_99_ = find(strcmp(ru_,tmp_rs_99_{nl})); assert(length(intersect(eo__{tmp_ij_99_},po__{npathway}))>0);
end;%for nl=1:length(tmp_rs_99_);
end;%if flag_check;
%%%%%%%%;
% Create masks (of indices along cdrop_a) ;
%%%%%%%%;
po_01_cu_mc_ = sum(cu_by_eu_xref_01__,2);
po_25_cu_mc_ = sum(cu_by_eu_xref_25__,2);
po_50_cu_mc_ = sum(cu_by_eu_xref_50__,2);
po_75_cu_mc_ = sum(cu_by_eu_xref_75__,2);
po_99_cu_mc_ = sum(cu_by_eu_xref_99__,2);
for npathway=1:n_pathway;
po_01_size_(npathway) = sum(po_01_cu_get__{npathway});
po_25_size_(npathway) = sum(po_25_cu_get__{npathway});
po_50_size_(npathway) = sum(po_50_cu_get__{npathway});
po_75_size_(npathway) = sum(po_75_cu_get__{npathway});
po_99_size_(npathway) = sum(po_99_cu_get__{npathway});
end;%for npathway=1:n_pathway;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%;

%%%%%%%%;
% Now calculate enrichment for all pathways. ;
% This abandons chebfun and just uses a gaussian approximation. ;
%%%%%%%%;
flag_plot=0;
log_pval_up_99__ = cell(n_pathway,1); % <-- upper integral; this is the log(p-value) associated with pathways that are over-represented . ;
log_pval_dn_99__ = cell(n_pathway,1); % <-- lower integral; this is the log(p-value) associated with pathways that are under-represented . ;
k_99__ = cell(n_pathway,1); K_99_ = zeros(n_pathway,1); M_99_ = zeros(n_pathway,1); m_99__ = cell(n_pathway,1);
if flag_plot; 
subplot(1,2,1); hold on; stairs(niter_,log(0.05)*ones(size(niter_)),'k:'); stairs(niter_,log(0.001)*ones(size(niter_)),'k:'); hold off;
subplot(1,2,2); hold on; stairs(niter_,log(0.05)*ones(size(niter_)),'k:'); stairs(niter_,log(0.001)*ones(size(niter_)),'k:'); hold off;
end;%if flag_plot; hold on;
tmp_N = sum(po_99_cu_mc_); 
[po_99_size_uni_,po_99_size_to_po_99_size_uni_,po_99_size_uni_to_po_99_size_] = unique(po_99_size_);
po_99_size_by_po_99_size_uni_xref_ = sparse(1:length(po_99_size_),po_99_size_uni_to_po_99_size_,1,length(po_99_size_),length(po_99_size_uni_));
for nl=length(po_99_size_uni_):-1:1;%for nl=1:length(po_99_size_uni_);
po_99_size = po_99_size_uni_(nl);
tmp_pij_ = find(sum(po_99_size_by_po_99_size_uni_xref_(:,nl),2));
disp(sprintf(' %% nl %d/%d: po_99_size %d, found %d',nl,length(po_99_size_uni_),po_99_size,length(tmp_pij_)));
tmp_K = po_99_size;
tmp_M = tmp_N-tmp_K; 
tmp_n_ = cumsum(po_99_cu_mc_,'reverse');
range_KM_ = [ [tmp_K/2] + tmp_K/2*1.00*[-1,+1] , [tmp_M/2] + tmp_M/2*1.00*[-1,+1] ]; %range_KM_ = [0,tmp_K,0,tmp_M];
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%;
for nl2=1:length(tmp_pij_);
assert(po_99_size_(tmp_pij_(nl2))==po_99_size);
npathway = tmp_pij_(nl2);
%%%%%%%%%%%%%%%%;
disp(sprintf(' %% %% %% npathway %d name %s original size %d snp_cdrop size %d',npathway,pathway_name_{npathway},length(po__{npathway}),full(sum(po_99_cu_get__{npathway}))));
tmp_k_mc_ = po_99_cu_get__{npathway};
tmp_k_ = cumsum(full(tmp_k_mc_),'reverse'); assert(min(tmp_k_)>=0 & max(tmp_k_)<=tmp_K);
tmp_m_ = full(tmp_n_ - tmp_k_); assert(min(tmp_m_)>=0 & max(tmp_m_)<=tmp_M);
tmp_pk_ = tmp_k_/max(1,tmp_K); tmp_qk_ = 1 - tmp_pk_;
tmp_pm_ = tmp_m_/max(1,tmp_M); tmp_qm_ = 1 - tmp_pm_; 
%%%%%%%%;
c_ij_ = length(cu_) - c_rem_ + 1;
log_pval_up_99_ = log(0.5)*ones(length(c_rem_),1); tmp_ij_ = find(tmp_pk_(c_ij_)>tmp_pm_(c_ij_)); 
if (length(tmp_ij_)>0); 
tmp_k_get_ = tmp_k_(c_ij_(tmp_ij_)); tmp_m_get_ = tmp_m_(c_ij_(tmp_ij_));
log_pval_up_99_(tmp_ij_) = shygecln(tmp_k_get_,tmp_N,tmp_K,tmp_m_get_+tmp_k_get_);
end;%if (length(tmp_ij_)>0); 
log_pval_up_99__{npathway} = log_pval_up_99_;
log_pval_dn_99_ = log(0.5)*ones(length(c_rem_),1); tmp_ij_ = find(tmp_pk_(c_ij_)<tmp_pm_(c_ij_)); 
if (length(tmp_ij_)>0); 
tmp_k_get_ = tmp_k_(c_ij_(tmp_ij_)); tmp_m_get_ = tmp_m_(c_ij_(tmp_ij_));
log_pval_dn_99_(tmp_ij_) = shygecln(tmp_K - tmp_k_get_,tmp_N,tmp_K,tmp_N - (tmp_m_get_+tmp_k_get_));
end;%if (length(tmp_ij_)>0); 
log_pval_dn_99__{npathway} = log_pval_dn_99_;
K_99_(npathway) = tmp_K; M_99_(npathway) = tmp_M; k_99__{npathway} = tmp_k_(c_ij_); m_99__{npathway} = tmp_m_(c_ij_);
if flag_plot;
subplot(1,2,1); hold on; stairs(niter_,log_pval_up_99_,'k-','LineWidth',0.5); hold off; 
ylim([-15,0]); xlim([1,length(c_rem_)]);
tic_ij_ = max(1,0:25:length(c_rem_));
%set(gca,'XTick',niter_(tic_ij_),'XTickLabel',c_rem_(tic_ij_)); xtickangle(90); xlabel('columns remaining');
set(gca,'XTick',niter_(tic_ij_),'XTickLabel',1+niter_(tic_ij_)); xtickangle(90); xlabel('iteration');
ylabel('log(pvalue up)');
subplot(1,2,2); hold on; stairs(niter_,log_pval_dn_99_,'k-','LineWidth',0.5); hold off; 
ylim([-15,0]); xlim([1,length(c_rem_)]);
tic_ij_ = max(1,0:25:length(c_rem_));
%set(gca,'XTick',niter_(tic_ij_),'XTickLabel',c_rem_(tic_ij_)); xtickangle(90); xlabel('columns remaining');
set(gca,'XTick',niter_(tic_ij_),'XTickLabel',1+niter_(tic_ij_)); xtickangle(90); xlabel('iteration');
ylabel('log(pvalue dn)');
drawnow();
end;%if flag_plot;
%%%%%%%%%%%%%%%%;
end;%for nl2=1:length(tmp_pij_);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%;
end;%for nl=1:length(po_99_size_uni_);

%%%%%%%%;
% Now calculate z-score for enrichment for all pathways. ;
%%%%%%%%;
z_99__ = cell(n_pathway,1); % <-- simple z-score associated with representation: assumes mean is n*P, and std is sqrt(n*P*(1-P)), where P = K/N . ;
for npathway=1:n_pathway;
tmp_K = K_99_(npathway); tmp_M = M_99_(npathway); tmp_N = tmp_K+tmp_M;
tmp_k_ = k_99__{npathway}; tmp_m_ = m_99__{npathway}; tmp_n_ = tmp_k_+tmp_m_;
tmp_P = tmp_K/max(1,tmp_N); tmp_avg_ = tmp_n_.*tmp_P; tmp_std_ = sqrt(tmp_n_.*tmp_P.*(1-tmp_P));
z_99__{npathway} = (tmp_k_ - tmp_avg_)./tmp_std_ ;
end;%for npathway=1:n_pathway;

%%%%%%%%;
% plot aggregate results. ;
%%%%%%%%;
colormap(colormap_beach());
imagesc( log(1+hist2d_0(repmat(niter_,1,n_pathway),cell2mat(transpose(log_pval_up_99__)),length(niter_),1501,[0,niter_(end)],[-15,0])) , [0,4] );
colorbar;
tic_ij_ = max(1,0:25:length(c_rem_));
%set(gca,'XTick',niter_(tic_ij_),'XTickLabel',c_rem_(tic_ij_)); xtickangle(90); xlabel('columns remaining');
set(gca,'XTick',niter_(tic_ij_),'XTickLabel',1+niter_(tic_ij_)); xtickangle(90); xlabel('iteration');
tmp_l_ = linspace(-15,0,1501); [~,~,tic_ij_] = intersect(-15:0,tmp_l_,'stable');
set(gca,'YTick',tic_ij_,'YTickLabel',-15:0); ylabel('log(pvalue)');

%%%%%%%%;
% list top enrichments. ;
%%%%%%%%;
ni = niter_(end)-750;
tmp_pval_up_99_ = cell2mat(transpose(log_pval_up_99__));
[~,tmp_ij_] = sort(tmp_pval_up_99_(ni,:));
for np=1:45;
npathway = tmp_ij_(np);
disp(sprintf(' %% ni %.5d: np %.5d/%.5d: npathway %.5d: (k%.5d/m%.5d/K%.5d) log10_pval %+8.4f \t %s ',ni,np,45,npathway,full(k_99__{npathway}(ni)),full(m_99__{npathway}(ni)),K_99_(npathway),log_pval_up_99__{npathway}(ni)/log(10),pathway_name_{npathway}));
end;%for np=1:45;

%%%%%%%%;
% list neuron-specific enrichments. ;
%%%%%%%%;
ni = niter_(end)-750;
tmp_pval_up_99_ = cell2mat(transpose(log_pval_up_99__));
tmp_ij1_ = find( cellfun('length',strfind(pathway_name_,'neuro')) | cellfun('length',strfind(pathway_name_,'synap')) | cellfun('length',strfind(pathway_name_,'axon')) ) ;
[~,tmp_ij2_] = sort(tmp_pval_up_99_(ni,tmp_ij1_));
for np=1:length(tmp_ij2_);
npathway = tmp_ij1_(tmp_ij2_(np));
disp(sprintf(' %% ni %.5d: np %.5d/%.5d: npathway %.5d: (k%.5d/m%.5d/K%.5d) log10_pval %+8.4f \t %s ',ni,np,45,npathway,full(k_99__{npathway}(ni)),full(m_99__{npathway}(ni)),K_99_(npathway),log_pval_up_99__{npathway}(ni)/log(10),pathway_name_{npathway}));
end;%for np=1:length(tmp_ij2_);

%%%%%%%%;
% plot z-score for neuron-specific enrichments. ;
%%%%%%%%;
tmp_ij1_ = find( cellfun('length',strfind(pathway_name_,'neuro')) | cellfun('length',strfind(pathway_name_,'synap')) | cellfun('length',strfind(pathway_name_,'axon')) ) ;
tmp_z_99__ = cell(length(tmp_ij1_),1);
for nl1=1:length(tmp_ij1_);
tmp_z_99__{nl1} = z_99__{tmp_ij1_(nl1)};
end;%for nl1=1:length(tmp_ij1_);
%%%%%%%%;
figure;clf; 
subplot(1,2,1);hold on;
plot(niter_,0*niter_,'k-'); 
for nl1=1:length(tmp_ij1_); plot(niter_,tmp_z_99__{nl1},'r-'); end;%for nl1=1:length(tmp_ij1_); %<-- 99th percentile. ;
hold off;
xlim([0,niter_(end)]);ylim([-5,5]);
xlabel('iteration'); ylabel('z-score'); title('z-score for neuron-specific enrichments');
subplot(1,2,2); hold on;
colormap(colormap_beach());
imagesc( log(1+hist2d_0(repmat(niter_,1,length(tmp_ij1_)),cell2mat(transpose(tmp_z_99__)),length(niter_),1+64,[0,niter_(end)],[-5,+5])) , [0,4] );
xlim([0,niter_(end)]);ylim([1,1+64]);
xlabel('iteration'); title('histogram (log-scale) for neuron-specific enrichments');
set(gca,'YTick',[]);
colorbar;

